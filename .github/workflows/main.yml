name: Build patched V8 d8

on:
  schedule:
    - cron: "0 2 * * *"
  workflow_dispatch:
    inputs:
      max_per_run:
        description: "本次最多处理多少个新版本（默认 30）"
        required: false
        default: "30"

permissions:
  contents: write
  actions: write

concurrency:
  group: build-patched-v8
  cancel-in-progress: false

env:
  V8_REPO: https://github.com/v8/v8.git
  MIN_VERSION: 12.6.1
  PATCH_FILE: patch.diff
  EXPECTED_PATCH_FILE_COUNT: "6"
  MAX_PER_RUN: ${{ github.event.inputs.max_per_run || '30' }}
  SLOTS_PER_OS: 6

jobs:
  determine-versions:
    name: Determine unprocessed versions
    runs-on: ubuntu-latest
    outputs:
      versions_json: ${{ steps.determine.outputs.versions }}
      has_versions: ${{ steps.determine.outputs.has_versions }}
      leftover_total: ${{ steps.determine.outputs.leftover_total }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Ensure tracking JSON
        run: |
          mkdir -p public
          [ -f public/version.json ] || echo "[]" > public/version.json
          [ -f public/failed.json ] || echo "[]" > public/failed.json

      - name: Determine versions
        id: determine
        run: python3 determine_versions.py

  build:
    name: Build slot ${{ matrix.slot }} (Linux)
    needs: determine-versions
    if: needs.determine-versions.outputs.has_versions == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        slot: [0, 1, 2, 3, 4, 5]
    env:
      ALL_VERSIONS: ${{ needs.determine-versions.outputs.versions_json }}
      SLOT_INDEX: ${{ matrix.slot }}
      SLOTS_PER_OS: 6
    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Write versions.json
        run: |
          echo '${{ env.ALL_VERSIONS }}' > versions.json

      - name: Partition versions
        id: partition
        run: python3 partition_versions.py
        env:
          VERSIONS_JSON: ${{ env.ALL_VERSIONS }}
          SLOT_INDEX: ${{ env.SLOT_INDEX }}
          SLOTS_PER_OS: ${{ env.SLOTS_PER_OS }}

      - name: No versions shortcut
        if: steps.partition.outputs.has_any == 'false'
        run: echo "This slot has no assigned versions."

      - name: Prepare (Linux)
        if: steps.partition.outputs.has_any == 'true'
        shell: bash
        run: |
          set -eux
          sudo apt-get update
          sudo apt-get install -y python3 python-is-python3 build-essential clang libglib2.0-dev flex bison git curl unzip pkg-config patch
          git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
          export PATH="$PWD/depot_tools:$PATH"
          echo "$PWD/depot_tools" >> $GITHUB_PATH
          python --version
          gclient --version

      - name: Initial sync (GitHub main repo)
        if: steps.partition.outputs.has_any == 'true'
        shell: bash
        run: |
          set -eux
          gclient config --name v8 --unmanaged https://github.com/v8/v8.git
          gclient sync --nohooks -D --no-history
          gclient runhooks

      - name: Copy helper scripts
        if: steps.partition.outputs.has_any == 'true'
        run: |
          cp apply_patch.py v8/
          cp patch.diff v8/
          cp partition_versions.py v8/ || true
          # 如果 build_versions_batch.py 里仍引用 Windows 逻辑，请同步删除相关分支
          cp build_versions_batch.py v8/ || true

      - name: Process versions batch
        if: steps.partition.outputs.has_any == 'true'
        shell: bash
        env:
          ASSIGNED_JSON: ${{ steps.partition.outputs.assigned_json }}
        run: |
          set -e
          python3 build_versions_batch.py || true
          echo "Batch processing complete (errors recorded in failed_versions.txt if any)."

      - name: Upload batch artifacts
        if: steps.partition.outputs.has_any == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: build-batch-linux-slot${{ matrix.slot }}
          path: |
            artifacts/**
            success_versions.txt
            failed_versions.txt
          retention-days: 7

  aggregate-and-release:
    name: Aggregate & release
    needs: [determine-versions, build]
    if: needs.determine-versions.outputs.has_versions == 'true'
    runs-on: ubuntu-latest
    outputs:
      leftover_total: ${{ needs.determine-versions.outputs.leftover_total }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download all batch artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloaded

      - name: Install tools
        run: |
          sudo apt-get update
            # jq & gh (gh 可选)
          sudo apt-get install -y jq
          gh --version || true

      - name: Merge success & failed
        run: |
          set -e
          mkdir -p public
          [ -f public/version.json ] || echo "[]" > public/version.json
          [ -f public/failed.json ]  || echo "[]" > public/failed.json
          # 收集并标准化行尾
          find downloaded -type f -name success_versions.txt -exec cat {} \; | tr -d '\r' | sed '/^$/d' | sort -u > _all_success.txt || true
          find downloaded -type f -name failed_versions.txt  -exec cat {} \; | tr -d '\r' | sed '/^$/d' | sort -u > _all_failed.txt  || true

          # 先把显式失败追加到 failed.json
          while read -r v; do
            [ -z "$v" ] && continue
            jq -e --arg v "$v" '.[] | select(. == $v)' public/failed.json >/dev/null || \
              jq --arg v "$v" '. + [$v]' public/failed.json > public/.tmp && mv public/.tmp public/failed.json
          done < _all_failed.txt || true

          # 记录成功版本
          updated=false
          while read -r v; do
            [ -z "$v" ] && continue
            if ! jq -e --arg v "$v" '.[] | select(. == $v)' public/version.json >/dev/null; then
              jq --arg v "$v" '. + [$v]' public/version.json > public/.tmp && mv public/.tmp public/version.json
              updated=true
            fi
          done < _all_success.txt || true

          # 排序
          if [ "$updated" = true ]; then
            jq '[.[]] | sort_by((split(".")+["0","0","0","0"])[0:4]|map(tonumber))' public/version.json > public/.tmp && mv public/.tmp public/version.json
          fi

      - name: Reconstruct per-version dirs (Linux only)
        run: |
          set -e
          mkdir -p stage
          # 查找所有 Linux d8 产物
          find downloaded -type f -name d8 | while read -r bin; do
            base=$(basename "$(dirname "$bin")")          # 例如 d8-12.6.3-Linux
            ver="${base#d8-}"
            ver="${ver%-Linux}"
            tgt="stage/d8-${ver}-Linux"
            mkdir -p "$tgt"
            cp "$bin" "$tgt/d8"
            chmod +x "$tgt/d8" || true
            rep_dir=$(dirname "$bin")
            [ -f "$rep_dir/apply_patch_report.txt" ] && cp "$rep_dir/apply_patch_report.txt" "$tgt/"
          done

      - name: Create releases & update version.json
        env:
          ALL_VERSIONS: ${{ needs.determine-versions.outputs.versions_json }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          [ -f public/version.json ] || echo "[]" > public/version.json
          updated=false
          for v in $(echo "${ALL_VERSIONS}" | jq -r '.[]'); do
            L="stage/d8-${v}-Linux/d8"
            if [ ! -f "$L" ]; then
              echo "Skip $v (missing Linux artifact)."
              continue
            fi
            mkdir -p "public/$v"
            cp "$L" "public/$v/d8-linux"
            if gh release view "$v" >/dev/null 2>&1; then
              echo "Release $v exists."
            else
              gh release create "$v" \
                "public/$v/d8-linux" \
                --title "$v" \
                --notes "Patched d8 (Linux) for V8 $v"
            fi
            if ! jq -e --arg v "$v" '.[] | select(. == $v)' public/version.json >/dev/null; then
              jq --arg v "$v" '. + [$v]' public/version.json > public/.tmp && mv public/.tmp public/version.json
              updated=true
            fi
          done
          if [ "$updated" = true ]; then
            jq '[.[]] | sort_by((split(".")+["0","0","0","0"])[0:4]|map(tonumber))' public/version.json > public/.tmp && mv public/.tmp public/version.json
          fi
          echo "version.json:"; cat public/version.json
          echo "failed.json:";  cat public/failed.json

      - name: Commit & push tracking
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if git diff --quiet -- public; then
            echo "No tracking changes."
            exit 0
          fi
            # 提交
          git add public
          git commit -m "Update tracking (Linux batch build) [skip ci]"
          git push

  trigger-next-batch:
    name: Trigger next batch
    needs: [aggregate-and-release]
    if: needs.determine-versions.outputs.leftover_total != '' && needs.determine-versions.outputs.leftover_total != '0'
    runs-on: ubuntu-latest
    steps:
      - name: Dispatch next
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEXT_MAX: ${{ env.MAX_PER_RUN }}
        run: |
          REF="${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"
          if [ -z "$REF" ]; then
            REF=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
              https://api.github.com/repos/${GITHUB_REPOSITORY} | jq -r '.default_branch')
          fi
          curl -s -X POST \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/main.yml/dispatches \
            -d "{\"ref\":\"${REF}\",\"inputs\":{\"max_per_run\":\"${NEXT_MAX}\"}}"
          echo "Next batch dispatched."
