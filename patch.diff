diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 1c37e97a380..cc1c3e48cfc 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -2296,6 +2296,127 @@ void Shell::RealmSharedSet(Local<Name> property, Local<Value> value,
   data->realm_shared_.Reset(isolate, value);
 }
 
+
+
+
+#include "src/objects/script.h"
+#include <iostream>
+
+static void Disassemble(v8::internal::Isolate* isolate, 
+                        v8::internal::Tagged<v8::internal::BytecodeArray> bytecode, 
+                        std::unordered_set<uintptr_t>& visited,
+                        int depth) {
+  if (depth > 100) { 
+    //v8::internal::PrintF("Recursion depth limit reached, aborting disassembly for this path.\n");
+    //fflush(stdout);
+    return;
+  }
+
+  uintptr_t key = reinterpret_cast<uintptr_t>(bytecode.ptr());
+  if (visited.count(key)) {
+    return;
+  }
+  visited.insert(key);
+
+  for (int i = 0; i < depth; ++i) v8::internal::PrintF("  ");
+  //v8::internal::PrintF("Disassembling BytecodeArray at: %p\n", reinterpret_cast<void*>(bytecode.ptr()));
+  //fflush(stdout);
+
+  // 这行是 V8 自己的反汇编输出，它使用 OFStream，是安全的
+  //v8::internal::OFStream os(stdout);
+  //bytecode->Disassemble(os);
+
+  auto consts = bytecode->constant_pool();
+  
+  //for (int i = 0; i < depth; ++i) v8::internal::PrintF("  ");
+  //v8::internal::PrintF("Constant pool size: %d\n", consts->length());
+  //fflush(stdout);
+
+  for (int i = 0; i < consts->length(); i++) {
+    auto obj = consts->get(i);
+    if (v8::internal::IsSharedFunctionInfo(obj)) {
+      auto shared = v8::internal::Cast<v8::internal::SharedFunctionInfo>(obj);
+      
+      //for (int i = 0; i < depth; ++i) v8::internal::PrintF("  ");
+      //v8::internal::PrintF("--> Found SFI in constant pool at index %d: ", i);
+      
+      auto function_name = shared->Name();
+      if (function_name->length() > 0) {
+          //v8::internal::PrintF("%s\n", function_name->ToCString().get());
+      } else {
+          //v8::internal::PrintF("(anonymous)\n");
+      }
+      //fflush(stdout);
+      
+      if (shared->HasBytecodeArray()) {
+          Disassemble(isolate, shared->GetBytecodeArray(isolate), visited, depth + 1);
+      } else {
+          //for (int i = 0; i < depth; ++i) v8::internal::PrintF("  ");
+          //v8::internal::PrintF("    (SFI has no bytecode array, skipping)\n");
+          //fflush(stdout);
+      }
+    }
+  }
+}
+
+// 修正后的 LoadJSC 函数
+void v8::Shell::LoadJSC(const v8::FunctionCallbackInfo<v8::Value>& args) {
+  auto isolate = reinterpret_cast<v8::internal::Isolate*>(args.GetIsolate());
+  for (int i = 0; i < args.Length(); i++) {
+    v8::String::Utf8Value filename(args.GetIsolate(), args[i]);
+    if (*filename == NULL) {
+      args.GetIsolate()->ThrowException(v8::Exception::Error(
+          v8::String::NewFromUtf8(args.GetIsolate(), "Error loading file").ToLocalChecked()));
+      return;
+    }
+    int length = 0;
+    auto filedata = reinterpret_cast<uint8_t*>(ReadChars(*filename, &length));
+    if (filedata == NULL) {
+      args.GetIsolate()->ThrowException(v8::Exception::Error(
+          v8::String::NewFromUtf8(args.GetIsolate(), "Error reading file").ToLocalChecked()));
+      return;
+    }
+    v8::internal::AlignedCachedData cached_data(filedata, length);
+    auto source = isolate->factory()
+                      ->NewStringFromUtf8(base::CStrVector("source"))
+                      .ToHandleChecked();
+v8::internal::MaybeHandle<v8::internal::SharedFunctionInfo> maybe_fun;
+#if (V8_MAJOR_VERSION > 12) || (V8_MAJOR_VERSION == 12 && V8_MINOR_VERSION >= 6)
+    v8::internal::ScriptDetails script_details;
+    maybe_fun = v8::internal::CodeSerializer::Deserialize(isolate, &cached_data, source, script_details);
+#else
+    v8::ScriptOriginOptions origin_options;
+    maybe_fun = v8::internal::CodeSerializer::Deserialize(isolate, &cached_data, source, origin_options);
+#endif
+    
+    v8::internal::Handle<v8::internal::SharedFunctionInfo> fun;
+    if (!maybe_fun.ToHandle(&fun)) {
+      args.GetIsolate()->ThrowException(v8::Exception::Error(
+          v8::String::NewFromUtf8(args.GetIsolate(), "Deserialize failed, possibly version mismatch or invalid .jsc file").ToLocalChecked()));
+      delete[] filedata;
+      return;
+    }
+
+    //v8::internal::PrintF("---- Starting disassembly of %s ----\n", *filename);
+    fflush(stdout);
+
+    std::unordered_set<uintptr_t> visited;
+    Disassemble(isolate, fun->GetBytecodeArray(isolate), visited, 0); 
+
+    //v8::internal::PrintF("---- Finished disassembly of %s ----\n", *filename);
+    fflush(stdout);
+
+    delete[] filedata;
+  }
+}
+
+
+
+
+
+
+
+
 void Shell::LogGetAndStop(const v8::FunctionCallbackInfo<v8::Value>& info) {
   DCHECK(i::ValidateCallbackInfo(info));
   Isolate* isolate = info.GetIsolate();
@@ -3601,6 +3722,10 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
                        FunctionTemplate::New(isolate, ExecuteFile));
+  global_template->Set(
+    v8::String::NewFromUtf8(isolate, "loadjsc", v8::NewStringType::kNormal)
+        .ToLocalChecked(),
+    v8::FunctionTemplate::New(isolate, v8::Shell::LoadJSC));
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
diff --git a/src/d8/d8.h b/src/d8/d8.h
index e8858334d30..e72e8f60196 100644
--- a/src/d8/d8.h
+++ b/src/d8/d8.h
@@ -537,6 +537,10 @@ class Shell : public i::AllStatic {
   static void ReportException(Isolate* isolate, Local<Message> message,
                               Local<Value> exception);
   static void ReportException(Isolate* isolate, const TryCatch& try_catch);
+
+
+  static void LoadJSC(const v8::FunctionCallbackInfo<v8::Value>& args);
+
   static MaybeLocal<String> ReadFile(Isolate* isolate, const char* name,
                                      bool should_throw = true);
   static Local<String> WasmLoadSourceMapCallback(Isolate* isolate,
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index 68262ec5caf..154fef2e2ae 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -2169,7 +2169,7 @@ void SharedFunctionInfo::SharedFunctionInfoPrint(std::ostream& os) {
   } else {
     os << kUnavailableString;
   }
-  PrintSourceCode(os);
+  //PrintSourceCode(os);
   // Script files are often large, thus only print their {Brief} representation.
   os << "\n - script: " << Brief(script());
   os << "\n - function token position: " << function_token_position();
@@ -2190,6 +2190,10 @@ void SharedFunctionInfo::SharedFunctionInfoPrint(std::ostream& os) {
   os << "\n - unique_id: " << unique_id();
   os << "\n - age: " << age();
   os << "\n";
+  os << "\nStart BytecodeArray\n";
+  this->GetActiveBytecodeArray(isolate)->Disassemble(os);
+  os << "\nEnd BytecodeArray\n";
+  os << std::flush;
 }
 
 void SharedFunctionInfoWrapper::SharedFunctionInfoWrapperPrint(
@@ -3150,6 +3154,33 @@ void HeapObject::Print(Tagged<Object> obj, std::ostream& os) {
 
 void HeapObject::HeapObjectShortPrint(std::ostream& os) {
   PtrComprCageBase cage_base = GetPtrComprCageBase();
+
+  // --- START OF OUR MODIFICATION (FINAL VERSION) ---
+  Isolate* isolate = nullptr;
+  if (!GetIsolateFromHeapObject(*this, &isolate) || isolate == nullptr) {
+    os << "<unknown>";
+    return;
+  }
+
+  // Now that we have the isolate, we can get the ReadOnlyRoots.
+  ReadOnlyRoots roots(isolate);
+  // Get the map of the current object using the correct API.
+  Tagged<Map> map_of_this_object = this->map(cage_base);
+
+  // Add an extra-safe check: A valid map pointer should not be null.
+  if (map_of_this_object.ptr() == kNullAddress) {
+    os << "<unknown>";
+    return;
+  }
+
+  // Check if the map's map is the meta_map. This is a strong indication
+  // that the object we are trying to print is valid.
+  if (map_of_this_object->map(cage_base) != roots.meta_map()) {
+    os << "<unknown>";
+    return;
+  }
+  // --- END OF OUR MODIFICATION ---
+
   os << AsHex::Address(this->ptr()) << " ";
 
   if (IsString(*this, cage_base)) {
@@ -3159,6 +3190,13 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
     os << accumulator.ToCString().get();
     return;
   }
+  if (map(cage_base)->instance_type() == ASM_WASM_DATA_TYPE) {
+    os << "<ArrayBoilerplateDescription> ";
+    Cast<ArrayBoilerplateDescription>(*this)
+        ->constant_elements()
+        ->HeapObjectShortPrint(os);
+    return;
+  }
   if (IsJSObject(*this, cage_base)) {
     HeapStringAllocator allocator;
     StringStream accumulator(&allocator);
@@ -3258,14 +3296,24 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
       break;
     case FIXED_ARRAY_TYPE:
       os << "<FixedArray[" << Cast<FixedArray>(*this)->length() << "]>";
+      os << "\nStart FixedArray\n";
+      Cast<FixedArray>(*this)->FixedArrayPrint(os);
+      os << "\nEnd FixedArray\n";
       break;
     case OBJECT_BOILERPLATE_DESCRIPTION_TYPE:
       os << "<ObjectBoilerplateDescription["
          << Cast<ObjectBoilerplateDescription>(*this)->capacity() << "]>";
+      os << "\nStart ObjectBoilerplateDescription\n";
+      Cast<ObjectBoilerplateDescription>(*this)
+          ->ObjectBoilerplateDescriptionPrint(os);
+      os << "\nEnd ObjectBoilerplateDescription\n";
       break;
     case FIXED_DOUBLE_ARRAY_TYPE:
       os << "<FixedDoubleArray[" << Cast<FixedDoubleArray>(*this)->length()
          << "]>";
+      os << "\nStart FixedDoubleArray\n";
+      Cast<FixedDoubleArray>(*this)->FixedDoubleArrayPrint(os);
+      os << "\nEnd FixedDoubleArray\n";
       break;
     case BYTE_ARRAY_TYPE:
       os << "<ByteArray[" << Cast<ByteArray>(*this)->length() << "]>";
@@ -3348,6 +3396,9 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
       } else {
         os << "<SharedFunctionInfo>";
       }
+      os << "\nStart SharedFunctionInfo\n";
+      shared->SharedFunctionInfoPrint(os);
+      os << "\nEnd SharedFunctionInfo\n";
       break;
     }
     case JS_MESSAGE_OBJECT_TYPE:
diff --git a/src/objects/string.cc b/src/objects/string.cc
index 28e40672b19..076b8fb9af8 100644
--- a/src/objects/string.cc
+++ b/src/objects/string.cc
@@ -659,12 +659,12 @@ void String::StringShortPrint(StringStream* accumulator) {
   accumulator->Add("<String[%u]: ", len);
   accumulator->Add(PrefixForDebugPrint());
 
-  if (len > kMaxShortPrintLength) {
-    accumulator->Add("...<truncated>>");
-    accumulator->Add(SuffixForDebugPrint());
-    accumulator->Put('>');
-    return;
-  }
+  //if (len > kMaxShortPrintLength) {
+  //  accumulator->Add("...<truncated>>");
+  //  accumulator->Add(SuffixForDebugPrint());
+  //  accumulator->Put('>');
+  //  return;
+  //}
 
   PrintUC16(accumulator, 0, len);
   accumulator->Add(SuffixForDebugPrint());
diff --git a/src/snapshot/code-serializer.cc b/src/snapshot/code-serializer.cc
index 04b71a59ca9..7de7a5237cd 100644
--- a/src/snapshot/code-serializer.cc
+++ b/src/snapshot/code-serializer.cc
@@ -482,6 +482,10 @@ MaybeHandle<SharedFunctionInfo> CodeSerializer::Deserialize(
     if (v8_flags.profile_deserialization) PrintF("[Deserializing failed]\n");
     return MaybeHandle<SharedFunctionInfo>();
   }
+  std::cout << "\nStart SharedFunctionInfo\n";
+  result->SharedFunctionInfoPrint(std::cout);
+  std::cout << "\nEnd SharedFunctionInfo\n";
+  std::cout << std::flush;
 
   // Check whether the newly deserialized data should be merged into an
   // existing Script from the Isolate compilation cache. If so, perform
@@ -699,10 +703,7 @@ SerializedCodeData::SerializedCodeData(const std::vector<uint8_t>* payload,
 SerializedCodeSanityCheckResult SerializedCodeData::SanityCheck(
     uint32_t expected_ro_snapshot_checksum,
     uint32_t expected_source_hash) const {
-  SerializedCodeSanityCheckResult result =
-      SanityCheckWithoutSource(expected_ro_snapshot_checksum);
-  if (result != SerializedCodeSanityCheckResult::kSuccess) return result;
-  return SanityCheckJustSource(expected_source_hash);
+  return SerializedCodeSanityCheckResult::kSuccess;
 }
 
 SerializedCodeSanityCheckResult SerializedCodeData::SanityCheckJustSource(
@@ -716,37 +717,7 @@ SerializedCodeSanityCheckResult SerializedCodeData::SanityCheckJustSource(
 
 SerializedCodeSanityCheckResult SerializedCodeData::SanityCheckWithoutSource(
     uint32_t expected_ro_snapshot_checksum) const {
-  if (size_ < kHeaderSize) {
-    return SerializedCodeSanityCheckResult::kInvalidHeader;
-  }
-  uint32_t magic_number = GetMagicNumber();
-  if (magic_number != kMagicNumber) {
-    return SerializedCodeSanityCheckResult::kMagicNumberMismatch;
-  }
-  uint32_t version_hash = GetHeaderValue(kVersionHashOffset);
-  if (version_hash != Version::Hash()) {
-    return SerializedCodeSanityCheckResult::kVersionMismatch;
-  }
-  uint32_t flags_hash = GetHeaderValue(kFlagHashOffset);
-  if (flags_hash != FlagList::Hash()) {
-    return SerializedCodeSanityCheckResult::kFlagsMismatch;
-  }
-  uint32_t ro_snapshot_checksum =
-      GetHeaderValue(kReadOnlySnapshotChecksumOffset);
-  if (ro_snapshot_checksum != expected_ro_snapshot_checksum) {
-    return SerializedCodeSanityCheckResult::kReadOnlySnapshotChecksumMismatch;
-  }
-  uint32_t payload_length = GetHeaderValue(kPayloadLengthOffset);
-  uint32_t max_payload_length = size_ - kHeaderSize;
-  if (payload_length > max_payload_length) {
-    return SerializedCodeSanityCheckResult::kLengthMismatch;
-  }
-  if (v8_flags.verify_snapshot_checksum) {
-    uint32_t checksum = GetHeaderValue(kChecksumOffset);
-    if (Checksum(ChecksummedContent()) != checksum) {
-      return SerializedCodeSanityCheckResult::kChecksumMismatch;
-    }
-  }
+  // Always return kSuccess to bypass all checks.
   return SerializedCodeSanityCheckResult::kSuccess;
 }
 
diff --git a/src/snapshot/deserializer.cc b/src/snapshot/deserializer.cc
index 7bc0586cd37..84d2dda9ee4 100644
--- a/src/snapshot/deserializer.cc
+++ b/src/snapshot/deserializer.cc
@@ -298,7 +298,7 @@ Deserializer<IsolateT>::Deserializer(IsolateT* isolate,
 #ifdef DEBUG
   num_api_references_ = GetNumApiReferences(isolate);
 #endif  // DEBUG
-  CHECK_EQ(magic_number_, SerializedData::kMagicNumber);
+  //CHECK_EQ(magic_number_, SerializedData::kMagicNumber);
 }
 
 template <typename IsolateT>
@@ -1014,6 +1014,22 @@ int Deserializer<IsolateT>::ReadReadOnlyHeapRef(uint8_t data,
   uint32_t chunk_offset = source_.GetUint30();
 
   ReadOnlySpace* read_only_space = isolate()->heap()->read_only_space();
+
+  // --- START OF OUR MODIFICATION ---
+  // Add bounds check to prevent crash.
+  if (chunk_index >= read_only_space->pages().size()) {
+    // If index is out of bounds, write a safe value (the_hole) and continue.
+    // This will likely result in a "bad" object, but prevents the crash.
+    
+    // --- FIX IS HERE ---
+    // We need to dereference the Handle<> to get the Tagged<> object.
+    Tagged<Hole> the_hole = *isolate()->factory()->the_hole_value();
+    
+    return WriteHeapPointer(slot_accessor, the_hole,
+                            GetAndResetNextReferenceDescriptor());
+  }
+  // --- END OF OUR MODIFICATION ---
+
   ReadOnlyPageMetadata* page = read_only_space->pages()[chunk_index];
   Address address = page->OffsetToAddress(chunk_offset);
   Tagged<HeapObject> heap_object = HeapObject::FromAddress(address);
